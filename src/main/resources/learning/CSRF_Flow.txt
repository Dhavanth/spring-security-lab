1. When a user interacts(public endpoint) with a web application or logs in, the application generates a unique CSRF token
and sends it to the client.
    1.1 Csrf token is generated by the CsrfTokenRepository which is implemented by following classes:
        1.1.1 CookieCsrfTokenRepository:
            - Stores the CSRF token in a cookie named XSRF-TOKEN on the client side/browser.
            - App reads the token from the cookie and expects it to be included in the request header/body as X-XSRF-TOKEN.
            - Preferred for stateless applications as it does not require server-side session management or server memory to store cookie.
        1.1.2 HttpSessionCsrfTokenRepository:
            - Stores in the server-side session and increases server memory usage.
            - Not preferred for stateless applications as it requires server-side session management.
    1.2 Token generation is LAZILY done by the CsrfTokenRepository, meaning it is generated only when needed to enhance performance.
2. The client stores the CSRF token, typically in a cookie or as a hidden field in forms.
3. CookieCsrfTokenRepository
    3.1 will persist the CSRF token in the cookie named XSRF-TOKEN until the browser is closed.
    3.2 set withHttpOnly(false) to allow JavaScript access -> Ensures JS reads the token and includes it in request header/body as X-XSRF-TOKEN.
4. To read the CSRF manually by our Spring app, we can create a custom filter that reads the CSRF token from the cookie and adds it to the response header.
Note: If we are sending the CSRF token in request header, can the malicious website read the CSRF token from the request header?
Ans: No, the malicious website cannot read the CSRF token from the request header due to the same-origin policy enforced by browsers.
This policy restricts how documents or scripts (JavaScript) loaded from one origin can interact with resources from another origin, preventing cross-origin access to sensitive data like CSRF tokens.
    4.1 CustomFilter extends OncePerRequestFilter -> This filter will get executed once per request.
    4.2 Fetch the token from the httpserveletrequest and pass the request to the next filter in the chain.
5. Add the custom filter to the filter chain in the Spring Security configuration to run after basic authentication filter
    5.1 This ensures that the CSRF token is read and added to the request header before it reaches the controller.
6. CsrfTokenRequestAttributeHandler
    6.1 To tell the CsrfFilter from where to read the csrf token in the request.
    6.2 This handler will read the CSRF token from the request header and set it in the request attribute with _csrf attribute name.
    6.3 Now the filter validates the CSRF token against the one stored in the cookie.
7. Spring Security will not store the jsessionid by default for stateless applications.
    7.1 Manage the session using the session creation policy in the security configuration. And set it as ALWAYS -> This will ensure that the session is created for every request.
    7.2 This is important because the CSRF token is stored in the session and needs to be available for validation.
    7.3 Also to tell the spring that I am not manually storing the session  rather you have to store it, we need to set the requireExplicitSave as false
